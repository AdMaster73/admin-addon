package com.github.adminfaces.starter.service;

import com.github.adminfaces.persistence.model.Filter;
import com.github.adminfaces.persistence.service.CrudService;
import com.github.adminfaces.template.exception.BusinessException;
import org.apache.deltaspike.data.api.criteria.Criteria;
import ${entity.getQualifiedName()};
import ${entity.getQualifiedName()}_;
import ${repository.getQualifiedName()};
import javax.ejb.Stateless;
import javax.inject.Inject;
import java.io.Serializable;
import java.util.*;

<#list fields as field>
   <#if hasToManyAssociation(field)>
import ${getArrayType(field).getQualifiedName()};   
import ${getArrayType(field).getQualifiedName()}_;   
   <#elseif hasToOneAssociation(field)>
import ${field.getType().getQualifiedName()};      
import ${field.getType().getQualifiedName()}_;   
   </#if> 
</#list>

import static com.github.adminfaces.template.util.Assert.has;

 
@Stateless
public class ${entity.getName()}Service extends CrudService<${entity.getName()}, ${nullablePrimaryKeyType}> implements Serializable {

    @Inject
    protected ${entity.getName()}Repository ${ccEntity}Repository;// you can use repositories to extract complex queries from your service


    /** 
     * This method is used for (real) pagination and is called by lazy PrimeFaces datatable on list page
     * @param filter holds restrictions populated on the list page
     * @return a criteria populated with given restrictions 
     */ 
    protected Criteria<${entity.getName()}, ${entity.getName()}> configRestrictions(Filter<${entity.getName()}> filter) {

        Criteria<${entity.getName()}, ${entity.getName()}> criteria = criteria();
        
<#list fields as field>
	<#if field.getName() != "serialVersionUID" && field.getName() != "version">
	    if (filter.hasParam("${field.getName()}")) {
	        <#if !hasAssociation(field)>
              criteria.eq(${entity.getName()}_.${field.getName()}, (${field.getType().getSimpleName()})filter.getParam("${field.getName()}"));   
            <#elseif hasToManyAssociation(field)>
            <#assign t = getArrayType(field).getSimpleName() >
             criteria.join(${entity.getName()}_.${field.getName()}, where(${t}.class)
 	  	            .in(${t}_.id, toListOfIds((${field.getType().getSimpleName()}<${getArrayType(field).getSimpleName()}>)filter.getParam("${field.getName()}"), new ${nullablePrimaryKeyType}[0])));   
            <#elseif hasToOneAssociation(field)>
             criteria.join(${entity.getName()}_.${field.getName()},
                    where(${field.getType().getSimpleName()}.class)
                    .eq(${field.getType().getSimpleName()}_.id, ((${field.getType().getSimpleName()})filter.getParam("${field.getName()}")).getId()));
            </#if>
	    }  
	</#if>
</#list>

        //create restrictions based on filter entity
        if (has(filter.getEntity())) {
            ${entity.getName()} filterEntity = filter.getEntity();
            
            /** just an example of restriction by entity
            if (has(filterEntity.getNamel())) {
                criteria.likeIgnoreCase(${entity.getName()}_.name, "%" + filterEntity.getName());
            } */
            
<#list fields as field>
	<#if field.getName() != "serialVersionUID" && field.getName() != "version" && !hasSkipJavadocTag(field)>
	        if (has(filterEntity.get${field.getName()?cap_first}())) {
            <#if !hasAssociation(field)>
             criteria.eq(${entity.getName()}_.${field.getName()}, filterEntity.get${field.getName()?cap_first}());   
            <#elseif hasToManyAssociation(field)>
            <#assign t = getArrayType(field).getSimpleName() >
             criteria.join(${entity.getName()}_.${field.getName()}, where(${t}.class)
 	  	            .in(${t}_.id, toListOfIds(filterEntity.get${field.getName()?cap_first}(), new ${nullablePrimaryKeyType}[0])));   
            <#elseif hasToOneAssociation(field)>
             criteria.join(${entity.getName()}_.${field.getName()},
                    where(${field.getType().getSimpleName()}.class)
                    .eq(${field.getType().getSimpleName()}_.id, filterEntity.get${field.getName()?cap_first}().getId()));
            </#if>
	        }  
	</#if>
</#list>
        }
        return criteria;
    }
    
    public void beforeInsert(${entity.getName()} ${ccEntity}) {
        validate(${ccEntity});
    }

    public void beforeUpdate(${entity.getName()} ${ccEntity}) {
        validate(${ccEntity});
    }

    public void validate(${entity.getName()} ${ccEntity}) {
        BusinessException be = new BusinessException();

        /** just an example of validation
        if (!car.hasModel()) {
            be.addException(new BusinessException("Car model cannot be empty"));
        }
        if (!car.hasName()) {
            be.addException(new BusinessException("Car name cannot be empty"));
        }

        if (!has(car.getPrice())) {
            be.addException(new BusinessException("Car price cannot be empty"));
        } 

        if (count(criteria()
                .eqIgnoreCase(Car_.name, car.getName())
                .notEq(Car_.id, car.getId())) > 0) {

            be.addException(new BusinessException("Car name must be unique"));
        }
        **/

        //if there is exceptions enqueued then throw them. Each business exception will be transformed into a JSF error message and displayed on the page
        if (has(be.getExceptionList())) {
            throw be;
        }
    }

<#list fields as field>
	<#if !hasAssociation(field) && !hasSkipJavadocTag(field) && hasAutoCompleteJavadocTag(field)>
    public List<String> get${field.getName()?cap_first}s(String query) {
        return criteria()
               .select(String.class, attribute(${entity.getName()}_.${field.getName()}))
               .likeIgnoreCase(${entity.getName()}_.${field.getName()}, "%" + query + "%")
               .getResultList();
    }    

	</#if>
</#list>
     

}
